import React, { useState } from 'react';
import type { FormData, FormErrors, Step } from '../types';

/**
 * Компонент пошаговой формы регистрации
 * 
 * Подумайте:
 * 1. Как организовать состояние формы? Что будет если хранить каждое поле отдельно?
 * 2. Как избежать повторной валидации уже проверенных шагов?
 * 3. Что произойдет с данными при переключении между шагами?
 */
export const RegistrationForm: React.FC = () => {
  // Подумайте, почему мы храним все данные в одном объекте,
  // а не разбиваем на отдельные состояния для каждого поля
  const [formData, setFormData] = useState<FormData>({
    personal: {
      firstName: '',
      lastName: '',
      email: ''
    },
    work: {
      company: '',
      position: '',
      experience: 0
    },
    additional: {
      bio: '',
      subscribe: false
    }
  });

  // Как можно использовать текущий шаг для оптимизации ререндеров?
  const [currentStep, setCurrentStep] = useState<Step>('personal');

  // Подумайте, когда лучше очищать ошибки:
  // при переходе между шагами или при изменении полей?
  const [errors, setErrors] = useState<FormErrors>({});

  /**
   * Обновление данных формы
   * 
   * Подумайте:
   * 1. Как обеспечить иммутабельность при обновлении вложенных полей?
   * 2. В какой момент лучше запускать валидацию?
   * 3. Как избежать лишних ререндеров при обновлении?
   */
  const updateFormData = (step: Step, field: string, value: string | number | boolean) => {
    // Изучите: как работает spread оператор с вложенными объектами?
    // Что может пойти не так при его использовании?
  };

  /**
   * Валидация текущего шага
   * 
   * Подумайте:
   * 1. Когда запускать валидацию? При каждом изменении или только при переходе?
   * 2. Как избежать повторной валидации уже проверенных данных?
   * 3. Где хранить правила валидации?
   */
  const validateStep = (step: Step): boolean => {
    // Изучите: какие есть подходы к валидации форм?
    // Чем отличается синхронная и асинхронная валидация?
    return false;
  };

  /**
   * Обработка переключения между шагами
   * 
   * Подумайте:
   * 1. Как обеспечить сохранность данных между шагами?
   * 2. Когда показывать ошибки пользователю?
   * 3. Как обрабатывать навигацию назад?
   */
  const handleStepChange = (direction: 'next' | 'prev') => {
    // Изучите: как работают конечные автоматы?
    // Как они могут помочь в управлении состоянием формы?
  };

  /**
   * Отправка формы
   * 
   * Подумайте:
   * 1. Как обрабатывать ошибки сети?
   * 2. Как показать прогресс отправки?
   * 3. Что делать с формой после успешной отправки?
   */
  const handleSubmit = async () => {
    // Изучите: как работает оптимистичное обновление UI?
    // В каких случаях его стоит применять?
  };

  return (
    <div className="registration-form">
      {/* Подумайте: как лучше организовать условный рендеринг шагов? */}
      <div className="progress-bar">
        {/* Изучите: как работают controlled vs uncontrolled компоненты */}
      </div>

      <div className="form-step">
        {currentStep === 'personal' && (
          // Подумайте: как избежать дублирования кода в формах?
          // Можно ли создать переиспользуемые компоненты?
          <div>
            {/* Изучите: как работает поднятие состояния (state lifting) */}
          </div>
        )}

        {currentStep === 'work' && (
          <div>
            {/* Подумайте: как организовать валидацию связанных полей? */}
          </div>
        )}

        {currentStep === 'additional' && (
          <div>
            {/* Изучите: как работает отложенная валидация полей */}
          </div>
        )}
      </div>

      <div className="form-navigation">
        {/* Подумайте: как сделать навигацию более интуитивной? */}
      </div>
    </div>
  );
};
